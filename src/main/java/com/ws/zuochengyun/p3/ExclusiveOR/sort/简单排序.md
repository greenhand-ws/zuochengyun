### 选择排序：一次遍历找到最小的值，放到最左边
### 冒泡排序：一次遍历找到最大值，放到最右边
### 插入排序：每次遍历，保证0~N是有序的（打扑克牌，新摸一张，插到他该在的位置）
- 插入排序比选择排序和冒泡排序好在于，他处理一个有序的数组，时间复杂度能到on
### 二分查找：left right mid 时间复杂度n(log2n默认为logn)
- 二分拓展：找数组中满足>=/<=某个数最左边最右边的下标

### 对数器：
> 实现两种方法，自己想要测试的方法算一个，再找一个或者用系统的。写一个生成随机样本的方法
> 用这些随机样本，对两个方法分别进行测试，多次大量数据之后，就能知道自己的方法是否对
> 作用于这些排序的话，自己写的方法算一个，系统提供的Arrays.sort()算一个，
> 每次自己方法的结果与arrays.sort匹配一下，就知道自己方法的正确性
